(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{370:function(a,t,r){"use strict";r.r(t);var v=r(45),s=Object(v.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"写在前面"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#写在前面"}},[a._v("#")]),a._v(" 写在前面")]),a._v(" "),r("p",[a._v("像C语言这种底层语言，一般都有底层的内存管理接口，比如malloc()和free()。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。")]),a._v(" "),r("h2",{attrs:{id:"内存管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[a._v("#")]),a._v(" 内存管理")]),a._v(" "),r("h3",{attrs:{id:"内存的生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存的生命周期"}},[a._v("#")]),a._v(" 内存的生命周期")]),a._v(" "),r("p",[a._v("不管是什么语言，内存的生命周期基本是一致的：")]),a._v(" "),r("ul",[r("li",[a._v("分配所需要的内存")]),a._v(" "),r("li",[a._v("使用分配到的内存（读，写）")]),a._v(" "),r("li",[a._v("不需要时将其释放/归还")])]),a._v(" "),r("h3",{attrs:{id:"内存分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[a._v("#")]),a._v(" 内存分配")]),a._v(" "),r("p",[a._v("在定义变量时，就完成了内存分配。")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('var n = 123; // 给数值变量分配内存\nvar s = "azerty"; // 给字符串分配内存\n\nvar o = {\n  a: 1,\n  b: null\n}; // 给对象及其包含的值分配内存\n\n\n')])])]),r("h3",{attrs:{id:"使用内存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用内存"}},[a._v("#")]),a._v(" 使用内存")]),a._v(" "),r("p",[a._v("这个过程实际上就是对分配的内存进行读取和写入的操作。")]),a._v(" "),r("h3",{attrs:{id:"当内存不再需要时释放"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#当内存不再需要时释放"}},[a._v("#")]),a._v(" 当内存不再需要时释放")]),a._v(" "),r("p",[a._v("大部分内存管理问题出现在这里，原因是难以找到哪些被分配的内存确实不再需要了，需要开发人员手动来释放。")]),a._v(" "),r("p",[a._v("JavaScript嵌入了‘垃圾回收器’，主要目的是跟踪内存的分配和使用，以便当分配的内存不再需要时，自动释放。")]),a._v(" "),r("p",[a._v("但这并不能完全解决上述的问题，因为要知道是否仍然需要这块内存是无法判定的。")]),a._v(" "),r("h2",{attrs:{id:"垃圾回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),r("p",[a._v("如上所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。")]),a._v(" "),r("h3",{attrs:{id:"引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[a._v("#")]),a._v(" 引用")]),a._v(" "),r("p",[a._v("垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。")]),a._v(" "),r("p",[a._v("在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。")]),a._v(" "),r("h3",{attrs:{id:"分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[a._v("#")]),a._v(" 分类")]),a._v(" "),r("p",[a._v("现在垃圾回收机制一般有两种方式：")]),a._v(" "),r("ul",[r("li",[a._v("引用计数")]),a._v(" "),r("li",[a._v("标记-清除")])]),a._v(" "),r("h3",{attrs:{id:"引用计数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[a._v("#")]),a._v(" 引用计数")]),a._v(" "),r("p",[a._v("这是最初级的算法，"),r("strong",[a._v("此算法把‘对象是否不再需要’简化为‘对象有没有被其他对象引用’。")]),a._v(" 如果没有引用该对象（零引用），对象将被回收。")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('var o = { \n  a: {\n    b:2\n  }\n}; \n// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o\n// 很显然，没有一个可以被垃圾收集\n\n\nvar o2 = o; // o2变量是第二个对“这个对象”的引用\n\no = 1;      // 现在，“这个对象”的原始引用o被o2替换了\n\nvar oa = o2.a; // 引用“这个对象”的a属性\n// 现在，“这个对象”有两个引用了，一个是o2，一个是oa\n\no2 = "yo"; // 最初的对象现在已经是零引用了\n           // 他可以被垃圾回收了\n           // 然而它的属性a的对象还在被oa引用，所以还不能回收\n\noa = null; // a属性的那个对象现在也是零引用了\n           // 它可以被垃圾回收了\n')])])]),r("h4",{attrs:{id:"限制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#限制"}},[a._v("#")]),a._v(" 限制")]),a._v(" "),r("p",[a._v("此算法有个限制："),r("strong",[a._v("无法处理循环引用的事例。")])]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('function f(){\n  var o = {};\n  var o2 = {};\n  o.a = o2; // o 引用 o2\n  o2.a = o; // o2 引用 o\n\n  return "azerty";\n}\n\nf();\n')])])]),r("p",[a._v("此事例中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。")]),a._v(" "),r("p",[r("em",[r("strong",[a._v("IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏。")])])]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('var div;\nwindow.onload = function(){\n  div = document.getElementById("myDivElement");\n  div.circularReference = div;\n  div.lotsOfData = new Array(10000).join("*");\n};\n')])])]),r("p",[a._v("myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。")]),a._v(" "),r("h3",{attrs:{id:"标记-清除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除"}},[a._v("#")]),a._v(" 标记-清除")]),a._v(" "),r("p",[r("strong",[a._v("这个算法把‘对象是否不再需要’定义为 ‘对象是否可以获得’")]),a._v(",\n这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。")]),a._v(" "),r("p",[a._v("从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。")]),a._v(" "),r("h4",{attrs:{id:"循环引用不再是问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#循环引用不再是问题"}},[a._v("#")]),a._v(" 循环引用不再是问题")]),a._v(" "),r("p",[a._v("在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。")]),a._v(" "),r("p",[a._v("但依然有个小小限制，即那些无法从根对象查询到的对象将会被清除。\n但在实践中，很少会碰到类似情况，这也是我们不太关心垃圾回收机制的原因。")]),a._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),r("p",[a._v("内存的生命周期分为三个部分，我们在定义变量时，占用了内存，在经历了相关操作后，变量不再需要时，将相关对象回收，释放内存。那如何回收呢，提供了两种方法，引用计数和标记清除，引用计数有个比较大的限制，那就是无法回收循环引用的对象，而标记清除方法不存在这个问题，虽然依然有个小小限制，但无伤大雅，二者区别在于算法定义的不同，以及基于此的算法方式不同。由此可见，垃圾回收并不能完全将不再需要的变量回收，这只是个优化内存的方式。")]),a._v(" "),r("h1",{attrs:{id:"参考文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),r("p",[r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management",target:"_blank",rel:"noopener noreferrer"}},[a._v("内存管理"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);